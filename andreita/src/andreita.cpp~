// this program randomly-generated velocity messages for turtlesim
#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <stdlib.h>
#include "std_msgs/String.h"
#include <sstream>


using namespace std;
ros::Publisher pub;





void observo(const std_msgs::String::ConstPtr& msg)
   {

//ROS_INFO("I heard: [%s]", msg->data.c_str());
//char a[]=msg->data.c_str();
string largo = msg->data.c_str();



geometry_msgs::Twist mes;

/*
if(largo=="veo un color") {

mes.linear.x=0.1;

ROS_INFO_STREAM("veo un color");

}
*/
if(largo=="no veo un color") {
mes.linear.x= 0.0; mes.angular.z=0.0;
ROS_INFO_STREAM("no veo");


}


if(largo=="obsDERE") { mes.angular.z=0.5; mes.linear.x= 0.0; ROS_INFO_STREAM("I");} 
if(largo=="evitarI") { mes.angular.z=-0.5; mes.linear.x= 0.0; ROS_INFO_STREAM("D");} 

if(largo=="izquierda") //izquierda

{ mes.angular.z =-0.5; mes.linear.x=0.1; ROS_INFO_STREAM("izquierda");	}
if(largo=="derecha") //derecha

{ mes.angular.z = 0.5;	mes.linear.x=0.1; ROS_INFO_STREAM("derecha");}

if(largo=="no")
{ mes.angular.z=0.0; mes.linear.x=0.1; ROS_INFO_STREAM("centro"); }

pub.publish(mes); 
		
}   



int main(int argc, char ** argv) {
	// init ROS
	ros::init(argc, argv, "andreita");
	ros::NodeHandle nh;


	// create a publisher object
pub = nh.advertise<geometry_msgs::Twist>("/cmd_vel", 1000);


	//crear subscriber
	

ros::Subscriber muevete = nh.subscribe("/semueve", 1000, observo);
ros::Subscriber obs = nh.subscribe("/esquiva", 1000, observo);

	
/*
	// seed random number generator
	srand(time(0));

	// loop at 2Hz until the node is shutdown
	ros::Rate rate(2);
	while(ros::ok) {
		//  create and fill in the message
		geometry_msgs::Twist msg;

		
		msg.linear.x= 0.0;
		msg.angular.z = 1.0;				



		// publish the message
		pub.publish(msg);

		// send a message to rosout
		
	ROS_INFO_STREAM(msg.linear.z);

		// wait until its time for another iteration
		ros::spinOnce();
		rate.sleep();
		
	}
*/
ros::spin();
return 0;
}
